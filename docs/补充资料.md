# Agent相关信息

## Iframe
code： 
```
<iframe width="100%" height="100%" allow="microphone *" src="https://www.gptbots.ai/widget/eek1z5tclbpvaoak5609epw/chat.html"></iframe>
```

### 高级用法

- 设置用户信息接口

1. 设置用户ID

- 方案一：网页嵌入 iframe 地址规则为：`iframe_url`+`?user_id=your_user_id`

> 说明：支持 Bot 开发者设置用户身份ID   

- 方案二：通过 javascript 代码动态设置用户ID

```
Array.from(document.getElementsByTagName('iframe')).filter(iframe => iframe.src.includes('gptbots')).forEach(iframe => iframe.contentWindow.postMessage('{"type":"UserId","data":"your_user_id"}', '*'))
```

2. 设置用户邮箱
   网页嵌入 iframe 地址规则为：`iframe_url`+`?email=somebody@mail.com`
   // 说明：支持 Bot 开发者设置用户邮箱，在用户呼叫人工服务时可免去填写邮箱的步骤，若不设置则用户发起人工服务请求时必须填写邮箱地址方可呼叫人工服务

```
### 事件回调数据格式
通过 Webhook 或 GA4 所传递的部件气泡的事件及事件属性采用以下数据格式，请自行解析后存储落库。
```JavaScript
{
  "clien_id": "",  //优先取使用 GA4 的 gtag 方法去获取 client id，无法获取则由 GPTBots 自行生成
  "user_id": "",  //开发者设置的 UserId,未设置则为 null
  "event_name": "Show widget bubble",     //事件名称
  "event_params": {  
	  "key1": "abc",  //事件属性名称:属性值(string)
	  "key2": 123     //事件属性名称:属性值(number)
	}
}
```


## 用户属性 API 文档
## 用户概述

用户是指 Agent/workflow 发起对话的终端用户，GPTBots 支持开发者为不同用户设置唯一身份标识ID，通过该用户ID`user_id`可以在不同渠道之间进行用户 身份关联，实现跨渠道用户身份合并、 通过 Tools 实现业务业务查询、维护用户属性和聊天记录等。

> 用户 CDP 信息存储于 Agent/workflow 之下，同个用户在不同的 Agent/Workflow 下数据是相互隔离的。

## 用户体系示意图

```
flowchart LR
 subgraph Col1["用户来源平台"]
        LC["Livechat"]
        IC["Intercom"]
        WG[" Widget "]
        TG["Telegram"]
  end
 subgraph Col2_5["来源平台子Channel"]
        tgb01["TGBOT01"]
        tgb02["TGBOT02"]
  end
 subgraph Col2["匿名 ID"]
        a1["lc0001"]
        a2["ic0001"]
        a3["wg0001"]
        tga1["tb0001"]
        tga2["tg0001"]
  end
 subgraph Col3["UserId"]
        U1["ABC123"]
        U2["ABC456"]
  end
 subgraph Col4["ConversationId"]
        c1["c001"]
        c2["c002"]
        c3["c003"]
        c4["c004"]
        c5["c005"]
  end
 subgraph Col5["Agent/Workflow"]
        Bot["Agent
        Workflow"]
  end
    LC -- 自动生成匿名ID --> a1
    IC -- 自动生成匿名ID --> a2
    WG -- 自动生成匿名ID --> a3
    TG -- 用户来源于子channel --> tgb01 & tgb02
    tgb01 -- 自动生成匿名ID --> tga1
    tgb02 -- 自动生成匿名ID --> tga2
    a1 -- 设置user_id --> U1
    a2 -- 设置user_id --> U1
    a3 -- 设置user_id --> U2
    tga1 -- 设置user_id --> U2
    tga2 -- 设置user_id --> U2
    U1 -- 生成新对话ID --> c1
    U1 -- 生成新对话ID --> c2
    U2 -- 生成新对话ID --> c3
    U2 -- 使用旧对话ID --> c4
    c4 -- 若过期（＞60分钟）
    自动生成新对话ID --> c5
    c1 --> Bot
    c2 --> Bot
    c3 --> Bot
    c4 --> Bot
    c5 --> Bot

     LC:::redStyle
     IC:::blueStyle
     WG:::greenStyle
     TG:::purpleStyle
     tgb01:::purpleStyle
     tgb02:::purpleStyle
     a1:::redStyle
     a2:::blueStyle
     a3:::greenStyle
     tga1:::purpleStyle
     tga2:::purpleStyle
     U1:::userGray
     U2:::userGray
     c1:::redStyle
     c2:::blueStyle
     c3:::greenStyle
     c4:::purpleStyle
     c5:::purpleStyle
    classDef userGray fill:#f5f5f5,stroke:#e6e6e6,color:#222
    classDef redStyle fill:#ffd6d6,stroke:#ffbdbd,color:#222
    classDef blueStyle fill:#dff0ff,stroke:#cfeaff,color:#222
    classDef greenStyle fill:#ecffd9,stroke:#d5ffb3,color:#222
    classDef purpleStyle fill:#f1e0ff,stroke:#e1c7ff,color:#222
    style Col1 stroke:#757575
```

## 定义

### 用户

用户是指与 Agent 产生对话的终端用户。

### 用户ID（user\_id）

由企业开发者为终端用户所赋予的身份唯一标识ID，通过 API 接口支持开发者为某个`匿名ID`设置`UserId`。UseId 的使用场景和高级用法请参考[设置用户ID](https://www.gptbots.ai/src/zh_CN/REST%20API/%E7%94%A8%E6%88%B7%20API/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7ID.md)。

### 匿名ID（anonymous\_id）

用户在三方平台（如：Telegram、WhatsApp、LINE等）与 Agent 进行对话时，GPTBots 会使用该三方平台的用户惟一标识符作为`anonymous_id`。 匿名ID的生成逻辑请参考\[匿名ID取值逻辑\](## 匿名ID取值逻辑)。

### 三方平台

GPTBots 平台当前支持将 Agent 集成至众多三方平台，包含：intercom 、webchat、 livechat 、 telegram 、 WhatsApp 等

### 对话ID（conversation\_id）

对话ID（conversation\_id）由 Agent、对话类型和 user\_id（anonymous\_id）所共同生成的惟一标识ID，`conversation_id`是不同业务场景隔离的最小单位（通常包含多个消息ID）。

### 消息ID（message\_id）

消息ID 即`message_id`用于标识 Agent 与用户的一次对话消息，是 Agent 与用户的一次对话的最小单位。

### 对话类型

**对话类型**（conversation\_type）用于标识用户发起对话场景，如：工作空间-Workflow、WhatsApp、API、工作空间-Search 等。

## 对话ID（conversation\_id）的生成原理

当用户通过三方平台与 Agent 发起对话时，系统会根据用户所在的三方平台，为用户生成的`anonymous_id`，并基于`anonymous_id`自动生成`conversation_id`用于承载用户与 Agent 的一轮对话。

## 匿名ID 取值逻辑

| 匿名ID来源平台 | 匿名ID取值逻辑 | 对应来源平台字段 | 说明 |
| --- | --- | --- | --- |
| Telegram | Telegram用户ID | tg\_user\_id | Telegram 用户的唯一数字标识符，用于区分不同用户 |
| Telegram 群聊 | Telegram chatID + Telegram 用户ID | tg\_chat\_id + tg\_user\_id | 群聊的聊天会话标识符与用户标识符的组合，用于在群组环境中唯一标识用户互动 |
| LINE | LINE 用户ID | line\_user\_id | LINE 用户的唯一标识符，用于识别平台内的个体用户 |
| LiveChat | LiveChat threadId | lc\_thread\_id | LiveChat 会话线程的唯一标识符，用于跟踪和管理用户对话线程 |
| Slack | Slack 用户ID | slack\_user\_id | Slack 用户的唯一标识符，用于识别平台内的个体用户 |
| Slack Public Channel | Slack(teamId+channelId+UserId) | slack\_team\_id + slack\_channel\_id + slack\_user\_id | Slack 团队标识符、公共频道标识符与用户标识符的组合，用于在公共频道中唯一标识用户 |
| Intercom | Intercom用户ID | intercom\_user\_id | Intercom 用户的唯一标识符，用于客户支持平台中的用户追踪和管理 |
| 钉钉 | 钉钉 senderId | dd\_user\_id | 钉钉用户的唯一标识符，用于企业协作平台中的用户区分 |
| 钉钉群聊 | 钉钉(senderId+群聊ID) | dd\_chat\_id + dd\_senderId | 钉钉分配给消息发送者的唯一标识符、群聊的唯一标识符，用于企业协作平台中的用户区分 |
| WhatsApp by meta | WhatsApp 用户 ID | wa\_user\_id | WhatsApp 用户的唯一标识符，通常基于用户的手机号码（例如，国际格式手机号码后缀@c.us） |
| WhatsApp by EngageLab | WhatsApp 用户 ID | wa\_user\_id | WhatsApp 用户的唯一标识符，通常基于用户的手机号码（例如，国际格式手机号码后缀@c.us） |
| Discord | Discord用户ID | discord\_user\_id | Discord 用户的唯一数字标识符，用于游戏和社区平台中的用户识别 |
| Instagram | Instagram senderId | instagram\_user\_id | Instagram 分配给消息发送者（即 Instagram 用户）的唯一标识符 |
| Facebook | senderId | facebook\_user\_id | Facebook 分配给消息发送者（即 Instagram 用户）的唯一标识符 |
| sobot | Sobot memberId | sobot\_memberId | sobot 用户 ID |
| Sobot 群聊@用户 | Sobot(guildId + channelId + memberId) | guildId + channelId + memberId | Sobot 群聊@用户的唯一标识符，用于在群聊环境中唯一标识用户互动 |
| Intercom | senderId | intercom\_senderId | Intercom 用户 ID |
| Zoho Sales IQ | zoho conversationId | zoho\_sales\_iq\_conversationId | Zoho Sales IQ 的对话惟一标识符 |
| 微信客服 | 微信客服用户ID | wechat\_customer\_service\_user\_id | 微信客服 用户 ID |

## GPTBots内置渠道匿名ID（anonymous\_id）取值逻辑

| 集成渠道 | 匿名ID取值逻辑 | 说明 |
| --- | --- | --- |
| API | 无匿名ID | 用户仅可使用user\_id生成对话ID |
| 工作空间 | 匿名ID=浏览器指纹ID | 基于浏览器指纹生成随机ID，清除缓存或无痕模式下可能会生成新的ID |
| 分享 | 匿名ID=浏览器指纹ID | 基于浏览器指纹生成随机ID，清除缓存或无痕模式下可能会生成新的ID |
| Iframe | 匿名ID=浏览器指纹ID | 基于浏览器指纹生成随机ID，清除缓存或无痕模式下可能会生成新的ID |
| AI搜索 | 匿名ID=浏览器指纹ID | 基于浏览器指纹生成随机ID，清除缓存或无痕模式下可能会生成新的ID |
| AI搜索（iframe） | 匿名ID=浏览器指纹ID | 基于浏览器指纹生成随机ID，清除缓存或无痕模式下可能会生成新的ID |
| Widget | 匿名ID=浏览器指纹ID | 基于浏览器指纹生成随机ID，清除缓存或无痕模式下可能会生成新的ID |

> 当用户已登录 GPTBots 平台时，系统自动将其 `GPTBots账户ID`设置为`user_id`，并自动关联`anonymous_id`（浏览器指纹ID）。

## 对话类型

**对话类型**（conversation\_type）用于标识用户发起对话场景，通过`conversation_type`字段值可以分场景查询日志数据。

| 对话类型 | 字段值 | 说明 |
| --- | --- | --- |
| 全部 | ALL | 全部类型来源的对话ID |
| 工作空间-Search | C | 工作空间Agent产生的对话ID |
| 工作空间-Agent | CHAT | 工作空间Search产生的对话ID |
| 工作空间-Workflow | C\_WORKFLOW | 工作空间 Workflow 产生的对话ID |
| 工作空间-Apps | C\_APPS | 工作空间 Market 各类 AI 应用产生的对话ID |
| API | API | API调用产生的对话ID |
| Iframe | EMBED | Iframe产生的对话ID |
| 部件气泡 | WIDGET | 部件气泡产生的对话ID |
| AI搜索 | AI\_SEARCH | AI搜索产生的对话ID |
| 分享 | SHARE | 分享产生的对话ID |
| WhatsApp by Meta | WHATSAPP\_META | WhatsApp by Meta产生的对话ID |
| WhatsApp by EngageLab | WHATSAPP\_ENGAGELAB | WhatsApp by EngageLab产生的对话ID |
| 钉钉机器人 | DINGTALK | 钉钉机器人产生的对话ID |
| Discord | DISCORD | Discord产生的对话ID |
| Slack | SLACK | Slack产生的对话ID |
| Zapier | ZAPIER | Zapier产生的对话ID |
| 微信客服 | WXKF | 微信客服产生的对话ID |
| Telegram | TELEGRAM | Telegram产生的对话ID |
| LiveChat | LIVECHAT | LiveChat产生的对话ID |
| LINE | LINE | LINE产生的对话ID，若存在多个LINE Channel，则会有多个Channel选项 |
| Instagram | INSTAGRAM | Instagram产生的对话ID |
| Facebook | FACEBOOK | Facebook产生的对话ID |
| Sobot | SO\_BOT | Sobot产生的对话ID |
| Zoho Sales IQ | ZOHO\_SALES\_IQ | Zoho Sales IQ产生的对话ID |
| Intercom | INTERCOM | Intercom产生的对话ID |

> ⚠️ 注意：表格中的字段值，可用于通过 [API获取对话列表](https://www.gptbots.ai/zh_CN/docs/api-reference/conversation-api/get-conversation-list)数据的筛选条件。  
> 如 LINE、Telegram 等支持添加多个通道的三方平台，「Agent-日志」进行筛选对话类型会支持 2 级类型。  
> 表格中的**字段值**，可在更新用户ID API中作为`anonymous_id_source`字段的值。


## 设置用户ID

GPTBots 支持开发者在不同渠道（如：网站、APP 、LiveChat ）为 Agent 用户设置唯一身份ID，通过该用户ID(`UserId`) 可以在不同渠道之间进行用户 身份关联，实现跨渠道用户身份合并、 通过 Tools 实现业务业务查询、维护用户属性和聊天记录等。具体应用场景如下：

+   Tools： AI Agent 在调用 Tools 向开发者业务 API 发起请求时，会将 UserId 放在 Header 中，便于开发者识别用户身份。
+   用户属性：开发者设置 UserId 后，用户属性信息将被归属于该 UserId。
+   对话日志：开发者设置 UserId 后，用户与 Agent 的对话日志记录将被归属于该 UserId。
+   对话日志：开发者设置 UserId 后，用户与 Agent 的对话日志记录将被归属于该 UserId。
+   事件回调： 开发者设置 UserId 后，在 iframe/widget 中所产生的事件回调上报至GA4/webhook 时会携带该信息。

> ⚠️用户ID(`UserId`) 应是用户在开发者业务系统内的唯一身份标识。通过该 UserId 可以查询到该用户的 VIP 等级、用户标签、用户订单等业务数据信息。

## API 设置用户ID

开发者通过 API 集成 Agent 能力为用户提供服务时，通常需要为不同的用户创建一个对话 ID（`conversation_id`） 作为提供 AI 服务的基础载体，创建`converstation_id` 的前提条件是必须设置一个用户ID 方可创建成功。

### 请求方式

`POST`

### 请求地址

`https://api-${endpoint}.gptbots.ai/v1/conversation`

### 请求示例

curl -X POST "https://api-${endpoint}.gptbots.ai/v1/conversation" \\ -H 'Authorization: Bearer ${API Key}' \\ -H 'Content-Type: application/json' \\ -d '{ "user\_id": "your\_user\_id" }'

```
                      
                      curl -X POST "https://api-${endpoint}.gptbots.ai/v1/conversation" \ 
-H 'Authorization: Bearer ${API Key}' \
-H 'Content-Type: application/json' \ 
-d '{
      "user_id": "your_user_id"
}'

                    
```

此代码块在浮窗中显示

创建 conversation\_id 的方法和具体指南请参考 [创建对话](https://www.gptbots.ai/src/zh_CN/API%20%E6%96%87%E6%A1%A3/Bot%E5%AF%B9%E8%AF%9D/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%AF%9D.md)。

## Bubble Widget 设置用户ID

开发者使用 Bubble Widget 方式集成 Agent 至开发者网站提供服务时，可在网站用户处于登录状态时，通过调用 GPTBots Bubble Widget SDK 提供的 API 接口设置用户ID。

window.ChatBot.setUserId("your\_user\_id") // 说明：支持 Agent 开发者设置自定义用户ID

```
                      
                      window.ChatBot.setUserId("your_user_id")
// 说明：支持 Agent 开发者设置自定义用户ID

                    
```

此代码块在浮窗中显示

更多详细的操作指南请参考 [部件气泡-高级用法](https://res.srcgptbots.com/aigc/docs/20241125/041420419/%E9%83%A8%E4%BB%B6%E6%B0%94%E6%B3%A1.md)。

## iframe 设置用户ID

开发者使用 iframe 方式集成 Agent 至开发者网站提供服务时，可在网站用户处于登录状态时，通过调用 GPTBots 提供的 iframe 方法设置用户ID。

+   方案一：网页嵌入 iframe 地址规则为：`iframe_url`+`?user_id=your_user_id`
    
    > 说明：支持 Agent 开发者设置用户身份ID，若不设置则使用 GPTBots 默认生成的用户身份ID
    
+   方案二：通过 javascript 代码动态设置用户ID

Array.from(document.getElementsByTagName('iframe')).filter(iframe => iframe.src.includes('gptbots')).forEach(iframe => iframe.contentWindow.postMessage('{"type":"UserId","data":"your\_user\_id"}', '\*'))

```
                      
                      Array.from(document.getElementsByTagName('iframe')).filter(iframe => iframe.src.includes('gptbots')).forEach(iframe => iframe.contentWindow.postMessage('{"type":"UserId","data":"your_user_id"}', '*'))

                    
```

此代码块在浮窗中显示

> 说明：以上是给 iframe 模式，动态设置 userId 的示例，将your\_user\_id 替换为实际的 userId 即可  
> 更多详细的操作指南请参考 [iframe-高级用法](https://res.srcgptbots.com/aigc/docs/20241125/041420420/iframe.md)。

## LiveChat 设置用户ID

当开发者使用 Livechat 的 Widget 面向网站用户提供客服服务，同时使用GPTBots AI Agent 提供[客户服务](https://res.srcgptbots.com/aigc/docs/20241125/041420420/Livechat.md)时，可通过设置用户ID 的方式实现`Agent用户`与`网站登录用户`之间的身份打通。可在网站用户处于登录状态时，通过调用 LiveChat Widget SDK 提供的 API 接口设置用户ID。

LiveChatWidget.call("set\_session\_variables", { user\_id: "your\_user\_id" // 网站用户登录后的身份ID });

```
                      
                      LiveChatWidget.call("set_session_variables", {
    user_id: "your_user_id"  // 网站用户登录后的身份ID
});

                    
```

此代码块在浮窗中显示

## 更新用户属性

支持通过 API 批量更新用户属性值，开发者可以根据业务需求，灵活设置用户属性，以便更好地进行用户画像和推荐。

### 请求方式

`POST`

### 调用地址

`https://api-${endpoint}.gptbots.ai/v1/property/update`

### Request Authentication

详情参见 [API 概述](https://www.gptbots.ai/src/zh_CN/API%20%E6%96%87%E6%A1%A3/%E6%A6%82%E8%BF%B0.md)的鉴权方式说明。

### 请求

#### 请求示例

#### 请求头

| 字段 | 类型 | 说明 |
| --- | --- | --- |
| Authorization | Bearer ${token} | 使用 Authorization: Bearer ${token}进行调用验证，请在 API 密钥页面获取密钥作为 token。 |
| Content-Type | application/json | 数据类型，取值为 application/json。 |

#### 请求参数

| 参数 | 类型 | 说明 | required |
| --- | --- | --- | --- |
| user\_id | string | 需要设置用户属性的用户id | true |
| property\_values | list | 待更新的属性列表 | true |
| property\_values.property\_name | string | 属性名称 | true |
| property\_values.value | object | 属性值 | true |

#### 响应

| 参数 | 类型 | 说明 |
| --- | --- | --- |
| success\_update | list | 成功更新的用户属性列表 |
| success\_update.propertyName | string | 成功更新的属性名称 |
| success\_update.value | object | 成功更新的属性值 |
| fail\_update | list | 更新失败的用户属性列表 |
| fail\_update.value | object | 更新失败的属性值 |
| fail\_update.property\_name | string | 新失败的属性名称 |


## 查询用户属性

支持开发者查询指定用户ID或匿名用户ID,批量查询用户属性值，每次查询最多支持100个用户ID或匿名用户ID。

## 请求方式

`GET`

## 调用地址

`https://api-${endpoint}/v2/user-property/query`

## 调用验证

详情参见 API 概述的鉴权方式说明。

## 请求

### 请求示例

### 请求头

| 字段 | 类型 | 说明 |
| --- | --- | --- |
| Authorization | Bearer ${token} | 使用 Authorization: Bearer ${token}进行调用验证，请在 API 密钥页面获取密钥作为 token。 |

### 请求参数

| 参数 | 类型 | 说明 | required |
| --- | --- | --- | --- |
| user\_ids | string | 需要查询用户属性的用户id | 必填，与anonymous\_ids二选一 |
| anonymouse\_ids | string | 需要查询用户属性的匿名用户id | 必填，与user\_ids二选一 |

> user\_id 与 anonymouse\_id 必须二选一，若均传入，则以 user\_id 为准。

## 响应

### 响应体

{ { "user\_id": "example\_user\_id\_1", "property\_values": \[ { "property\_name": "example\_property\_name", "value": "example\_value" }, { "property\_name": "example\_property\_name", "value": "example\_value" } \] }, { "anonymous\_id": "example\_anonymous\_id\_2", "property\_values": \[ { "property\_name": "example\_property\_name", "value": "example\_value" }, { "property\_name": "example\_property\_name", "value": "example\_value" } \] } }

```
                      
                      {
  {
    "user_id": "example_user_id_1",
    "property_values": [
      {
        "property_name": "example_property_name",
        "value": "example_value"
      },
      {
        "property_name": "example_property_name",
        "value": "example_value"
      }
    ]
  },
  {
    "anonymous_id": "example_anonymous_id_2",
    "property_values": [
      {
        "property_name": "example_property_name",
        "value": "example_value"
      },
      {
        "property_name": "example_property_name",
        "value": "example_value"
      }
    ]
  }
}

                    
```

此代码块在浮窗中显示

### 成功响应

| 参数 | 类型 | 说明 |
| --- | --- | --- |
| user\_id | string | 所查询的user\_id |
| anonymous\_id | string | 所查询的anonymous\_id |
| property\_values | list | user\_id的用户属性和属性值列表 |
| property\_name | string | 用户属性名称 |
| value | object | 用户属性值 |

### 失败响应

| 参数 | 类型 | 说明 |
| --- | --- | --- |
| code | int | 错误码 |
| message | string | 错误信息 |

### 状态码

| 状态码 | 说明 |
| --- | --- |
| 200 | 成功 |
| 400 | 参数错误 |
| 401 | 未授权 |
| 403 | 权限不足 |
| 500 | 服务器错误 |
| 503 | user\_id不存在 |
| 504 | 匿名用户ID不存在 |




## 重申一遍业务逻辑
1. 请你先模拟5个患者的姓名，香港电话，邮件，以及年龄，身份证，地址，工作等信息存入数据库
2. 在用户使用网站时登录核对匹配数据库中的邮件和电话
3. 一旦验证通过后，通过api的形式将用户的关键信息传入iframe中
4. 用户可参与iframe中agent的对话

## 完善代码且得到我的批准后再运行下面的操作
- 完善代码后请在该账号下新建repo推送本项目
- 我的github： https://github.com/CurtisYoung18
- 同时，我的vercel账号也是同一个github账号登录的